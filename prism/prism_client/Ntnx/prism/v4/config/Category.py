# coding: utf-8


"""
IGNORE:
    Nutanix Prism Versioned APIs

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 0.0.1-SNAPSHOT
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from prism_client.Ntnx.common.v1.config.KVPair import KVPair  # noqa: F401,E501
from prism_client.Ntnx.prism.v4.config.CategoryAssociationSummary import CategoryAssociationSummary  # noqa: F401,E501
from prism_client.Ntnx.prism.v4.config.CategorySummary import CategorySummary  # noqa: F401,E501
from prism_client.Ntnx.prism.v4.config.CategoryType import CategoryType  # noqa: F401,E501

"""
IGNORE:
NOTE: This class is auto generated by the swagger code generator program.

Do not edit the class manually.
IGNORE
"""

class Category(CategorySummary):
    """Category - a model defined in Swagger"""
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """ # noqa: E501
    swagger_types = {
        'metadata': 'list[common.v1.config.KVPair]',
        'fq_name': 'str',
        'name': 'str',
        'parent_ext_id': 'str',
        'user_specified_name': 'str',
        'type': 'prism.v4.config.CategoryType',
        'description': 'str',
        'associations': 'list[prism.v4.config.CategoryAssociationSummary]',
        'child_categories': 'list[prism.v4.config.CategorySummary]',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'metadata': 'metadata',
        'fq_name': 'fqName',
        'name': 'name',
        'parent_ext_id': 'parentExtId',
        'user_specified_name': 'userSpecifiedName',
        'type': 'type',
        'description': 'description',
        'associations': 'associations',
        'child_categories': 'childCategories',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, metadata=None, fq_name=None, name=None, parent_ext_id=None, user_specified_name=None, type=None, description=None, associations=None, child_categories=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        """Category - a model defined in Swagger
            \nThere are three category types: - SYSTEM: Defined by an administrator. Cannot be modified by the user. - INTERNAL: Defined by any internal process within Nutanix ecosystem. Cannot be viewed directly through a list call.             Can be modified by the user. - USER: Defined by a user through the v4 api Currently v4 apis allow the creation of only User Category Type. 
        """
        CategorySummary.__init__(self, fq_name, name, parent_ext_id, user_specified_name, type, description, associations, child_categories, ext_id, links, tenant_id, *args, **kwargs)
        self._metadata = None
        self.discriminator = None
        if metadata is not None:
            self._metadata = metadata

    def _initialize_object_type(self):
        return 'prism.v4.config.Category'

    def _initialize_fq_object_type(self):
        return 'prism.v4.r0.a1.config.Category'


    @property
    def metadata(self):
        """`{ list[common.v1.config.KVPair] }`
            \nOpaque metadata which can be associated to a category.<br> It is a list of key-value pairs.<br> For example, for a category 'California/SanJose' we can associate a geographical coordinate based metadata like: {'latitude': '37.3382° N' , 'longitude': '121.8863° W'}.  The server does not validate this value nor does it enforce the uniqueness or any other constraints. It is the responsibility of the user to ensure that any semantic or syntactic constraints are retained when mutating this field. 
        """ # noqa: E501
        return self._metadata

    @metadata.setter
    def metadata(self, metadata):

        self._metadata = metadata

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, attr_type in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Category, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Category):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

